# Docker

Docker 是目前火热的容器化虚拟化技术，每一个 Docker 容器都是一个精简的 Linux 虚拟机，通过 Docker 可以实现部署项目的环境统一，持续集成和发布。文章主要是在 CentOS7 下 Docker 的基础使用。
文档：[https://docs.docker.com](https://docs.docker.com/)

## 为什么会出现

## 历史

![image-20200514193557351](http://img.zhaojishun.cn/img/image-20200514193557351.png)

## 文档资料

![image-20200514194028833](http://img.zhaojishun.cn/img/image-20200514194028833.png)

## docker可以干什么

![image-20200514194257516](http://img.zhaojishun.cn/img/image-20200514194257516.png)

![image-20200514194353256](http://img.zhaojishun.cn/img/image-20200514194353256.png)

![image-20200514194541704](http://img.zhaojishun.cn/img/image-20200514194541704.png)

![image-20200514194639567](http://img.zhaojishun.cn/img/image-20200514194639567.png)

![image-20200514194729939](file:///E:/Typora/upload/image-20200514194729939.png)

![image-20200514195109082](http://img.zhaojishun.cn/img/image-20200514195109082.png)

![image-20200514195425405](http://img.zhaojishun.cn/img/image-20200514195425405.png)

# Docker 组成

![image-20200514195834727](http://img.zhaojishun.cn/img/image-20200514195834727.png)

![image.png](https://img.hacpai.com/file/2019/10/image-67305af4.png?imageView2/2/w/1280/format/jpg/interlace/1/q/100)

- 镜像(Image)
  Docker 中的镜像相当于我们 VM 虚拟机中使用的 iso 文件

  ![image-20200514200124227](http://img.zhaojishun.cn/img/image-20200514200124227.png)

- 容器(Container)
  容器可以类比成是一个正在运行的虚拟机

![image-20200514200230803](http://img.zhaojishun.cn/img/image-20200514200230803.png)

- tar 文件
  Docker 镜像可以保存成一个 tar 文件，同样的 tar 文件也可以通过 load 命令加载成一个镜像，然后通过镜像运行成一个容器。
- Dockerfile
  Docker 的构建文件，可以通过 Dockerfile 文件构建成一个 Docker 镜像
- 仓库(Repository)
  远程仓库，上面有很多已经做好的镜像，比如 MySQL，nginx 等，通过 pull 命令拉取镜像，通过 push 命令推送镜像

------

PS ：镜像与容器的关系很像 Java 中的类与实例的关系，一个镜像可以实例化出多个容器，多个容器之间互不干扰，一个类可以有无数个实例，同样的一个镜像可以有无数个实例。

# Docker 的安装、启动、卸载

## centos下安装

> 1、安装gcc

```
yum -y install gcc
yum -y install gcc-c++
```

> 2、CentOS 下需要卸载旧的版本

```
yum -y remove docker docker-common docker-selinux docker-engine
```

2018.3官网版本卸载

```
yum remove docker \
                  docker-client \
                  docker-client-latest \
                  docker-common \
                  docker-latest \
                  docker-latest-logrotate \
                  docker-logrotate \
                  docker-engine
```

> 3、安装所需软件包

```
yum install -y yum-utils device-mapper-persistent-data lvm2
```

> 4、设置stable镜像仓库

```
yum-config-manager --add-repo http://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo
```

> 5、更新yum软件包索引

```
yum makecache fast
```

> 6、安装DOCKER CE

```
yum -y install docker-ce
```

> 7、启动 Docker

```
systemctl start docker
```

> 测试 是否安装成功

```
docker version
docker run hello-world
```

## 阿里云镜像加速

```
sudo mkdir -p /etc/docker
sudo tee /etc/docker/daemon.json <<-'EOF'
{
  "registry-mirrors": ["https://b32o6mfv.mirror.aliyuncs.com"]
}
EOF
sudo systemctl daemon-reload
sudo systemctl restart docker
```

## 卸载

```
//卸载程序
yum remove docker-ce docker-ce-cli containerd.io
//删除默认路径
rm -rf /var/lib/docker
```

## docker是如何工作的

![image-20200515071228276](http://img.zhaojishun.cn/img/image-20200515071228276.png)

![image-20200515071217313](http://img.zhaojishun.cn/img/image-20200515071217313.png)

# 常用命令

## 帮助命令

```
docker version  #显示docker 的版本信息
docker info     #显示docker的详细信息
docker --help	#帮助命令
```

命令帮助文档：https://docs.docker.com/engine/reference/commandline

## 镜像命令

### 列出本地镜像`docker images`

```
docker images
```

![image-20200511203013354](http://img.zhaojishun.cn/img/image-20200511203013354.png)

- REPOSITORY：表示镜像的仓库源
- TAG：镜像的标签`latest`为默认
- IMAGE ID：镜像ID
- CREATED：镜像创建时间
- SIZE：镜像大小

> 同一仓库源可以有多个 TAG，代表这个仓库源的不同个版本，我们使用 REPOSITORY:TAG 来定义不同的镜像。
>
> 如果你不指定一个镜像的版本标签，例如你只使用 ubuntu，docker 将默认使用 ubuntu:latest 镜像

#### `-a` :列出本地所有的镜像（含中间映像层）

```
docker images -a
```

#### `-q` :只显示镜像ID。

```
docker images -q
```

![image-20200511203406595](http://img.zhaojishun.cn/img/image-20200511203406595.png)

### `docker search` 搜索镜像

```
docker search tomcat 
# 可选项
[--filter=STARS=3000] 搜索出的镜像start大于3000
```

![image-20200511205419516](http://img.zhaojishun.cn/img/image-20200511205419516.png)

### `docker pull` 拉取镜像

```
# docker pull imgName[:tag] //不写tag默认拉取latest
docker pull nginx
#分层下载 docker的核心，联合文件系统
[root@localhost ~]# docker pull nginx
Using default tag: latest
latest: Pulling from library/nginx
54fec2fa59d0: Already exists 
4ede6f09aefe: Pull complete 
f9dc69acb465: Pull complete 
Digest: sha256:404ed8de56dd47adadadf9e2641b1ba6ad5ce69abf251421f91d7601a2808ebe
Status: Downloaded newer image for nginx:latest
docker.io/library/nginx:latest
```

### `docker rmi`删除镜像

删除单个

```
docker rmi -f 镜像id
```

删除多个

```
docker rmi -f 镜像id1 镜像id2
```

删除全部

```
docker rmi -f $(docker images -qa)
```

## 容器命令

> 有镜像才能创建容器，这是根本前提(下载一个CentOS镜像演示)

### `docker run`新建并启动容器

```
docker run [options] image [command] [arg...]
docker run -it -d --name=mysql01 -p3333:3333 mysql
```

- `--name="容器新名字":` 为容器指定一个名称；

- `-d: 后台运行容器`，并返回容器ID，也即启动守护式容器； 类似nohup

- `-i`：以交互模式运行容器，通常与 -t 同时使用；

- `-t`：为容器重新分配一个伪输入终端，通常与 -i 同时使用；

- `-P`: 随机端口映射；

- ```
  -p
  ```

  : 指定端口映射，有以下四种格式

  - ip:hostPort:containerPort
  - ip::containerPort
  - hostPort:containerPort
  - containerPort

> 运行流程图

![image-20200515070922860](http://img.zhaojishun.cn/img/image-20200515070922860.png)

### `docker ps`列出正在运行的容器

```
docker ps
```

![image-20200512101009595](http://img.zhaojishun.cn/img/image-20200512101009595.png)

- `-a` :列出当前所有正在运行的容器+历史上运行过的
- -l :显示最近创建的容器。
- -n=1：显示最近1个创建的容器。
- `-q` :静默模式，只显示容器编号。
- --no-trunc :不截断输出。(显示完整容器id)

### 退出容器

1. 容器停止退出

```
exit
```

1. 容器不停止退出

```
ctrl+p+q
```

### `docker rm` 删除容器

```
docker rm 容器id                 # 删除一个容器，正在运行的容器不能删除，强制删除用 -f 
docker rm -f $(docker ps -aq)	#删除所有容器
```

### `docker start`启动容器

```
docker start 容器id或容器名
```

### `docker restart`重启容器

```
docker restart 容器id或容器名
```

### `docker stop`停止容器

```
docker stop 容器id或容器名
```

### `docker kill` 强制停止容器

```
docker kill 容器id或容器名
```

## 重要命令

#### 守护式容器

```
docker run -d 容器名
```

很重要的要说明的一点: Docker容器`后台运行`,就`必须有一个前台进程`.

容器运行的命令如果不是那些`一直挂起`的命令（比如运行top，tail），就是会`自动退出`的。

这个是docker的机制问题,比如你的web容器,我们以nginx为例，正常情况下,我们配置启动服务只需要启动响应的service即可。例如

service nginx start

但是,这样做,nginx为后台进程模式运行,就导致docker前台没有运行的应用,

这样的容器后台启动后,会立即自杀因为他觉得他没事可做了.

所以，最佳的解决方案是,将你要运行的程序`以前台进程的形式运行`

```
docker run -it centos /bin/bash
```

#### 查看容器日志

```
docker logs -f -t --tail 容器ID
```

- -t 加入时间戳
- -f 跟随最新的日志打印
- --tail 数字 显示最后多少条

#### 查看容器内运行的进程

```
docker top 容器id
```

#### 进入运行的容器并以命令行交互

1、

```
docker exec -it 容器id bashshell
```

> 一般的bashshell为/bin/bash

1. 重新进入docker attach 容器ID

```
docker attach 容器id
```

#### 从容器拷贝文件到宿主机

> 容器处于关闭状态也可拷贝

```
docker cp 容器ID:容器内路径 目的主机路径
```

#### 查看容器的元数据

```
docker inspect 容器id
[
    {
        "Id": "21d8bc7c77b55732793ea85267ebd9f63c1cd11ea597c9995ba49d827dc2d1b1",
        "Created": "2020-05-15T06:36:11.576573516Z",
        "Path": "/bin/bash",
        "Args": [],
        "State": {
            "Status": "running",
            "Running": true,
            "Paused": false,
            "Restarting": false,
            "OOMKilled": false,
            "Dead": false,
            "Pid": 3201,
            "ExitCode": 0,
            "Error": "",
            "StartedAt": "2020-05-15T06:36:12.466152437Z",
            "FinishedAt": "0001-01-01T00:00:00Z"
        },
        "Image": "sha256:470671670cac686c7cf0081e0b37da2e9f4f768ddc5f6a26102ccd1c6954c1ee",
        "ResolvConfPath": "/var/lib/docker/containers/21d8bc7c77b55732793ea85267ebd9f63c1cd11ea597c9995ba49d827dc2d1b1/resolv.conf",
        "HostnamePath": "/var/lib/docker/containers/21d8bc7c77b55732793ea85267ebd9f63c1cd11ea597c9995ba49d827dc2d1b1/hostname",
        "HostsPath": "/var/lib/docker/containers/21d8bc7c77b55732793ea85267ebd9f63c1cd11ea597c9995ba49d827dc2d1b1/hosts",
        "LogPath": "/var/lib/docker/containers/21d8bc7c77b55732793ea85267ebd9f63c1cd11ea597c9995ba49d827dc2d1b1/21d8bc7c77b55732793ea85267ebd9f63c1cd11ea597c9995ba49d827dc2d1b1-json.log",
        "Name": "/determined_wiles",
        "RestartCount": 0,
        "Driver": "overlay2",
        "Platform": "linux",
        "MountLabel": "",
        "ProcessLabel": "",
        "AppArmorProfile": "",
        "ExecIDs": null,
        "HostConfig": {
            "Binds": null,
            "ContainerIDFile": "",
            "LogConfig": {
                "Type": "json-file",
                "Config": {}
            },
            "NetworkMode": "default",
            "PortBindings": {},
            "RestartPolicy": {
                "Name": "no",
                "MaximumRetryCount": 0
            },
            "AutoRemove": false,
            "VolumeDriver": "",
            "VolumesFrom": null,
            "CapAdd": null,
            "CapDrop": null,
            "Capabilities": null,
            "Dns": [],
            "DnsOptions": [],
            "DnsSearch": [],
            "ExtraHosts": null,
            "GroupAdd": null,
            "IpcMode": "private",
            "Cgroup": "",
            "Links": null,
            "OomScoreAdj": 0,
            "PidMode": "",
            "Privileged": false,
            "PublishAllPorts": false,
            "ReadonlyRootfs": false,
            "SecurityOpt": null,
            "UTSMode": "",
            "UsernsMode": "",
            "ShmSize": 67108864,
            "Runtime": "runc",
            "ConsoleSize": [
                0,
                0
            ],
            "Isolation": "",
            "CpuShares": 0,
            "Memory": 0,
            "NanoCpus": 0,
            "CgroupParent": "",
            "BlkioWeight": 0,
            "BlkioWeightDevice": [],
            "BlkioDeviceReadBps": null,
            "BlkioDeviceWriteBps": null,
            "BlkioDeviceReadIOps": null,
            "BlkioDeviceWriteIOps": null,
            "CpuPeriod": 0,
            "CpuQuota": 0,
            "CpuRealtimePeriod": 0,
            "CpuRealtimeRuntime": 0,
            "CpusetCpus": "",
            "CpusetMems": "",
            "Devices": [],
            "DeviceCgroupRules": null,
            "DeviceRequests": null,
            "KernelMemory": 0,
            "KernelMemoryTCP": 0,
            "MemoryReservation": 0,
            "MemorySwap": 0,
            "MemorySwappiness": null,
            "OomKillDisable": false,
            "PidsLimit": null,
            "Ulimits": null,
            "CpuCount": 0,
            "CpuPercent": 0,
            "IOMaximumIOps": 0,
            "IOMaximumBandwidth": 0,
            "MaskedPaths": [
                "/proc/asound",
                "/proc/acpi",
                "/proc/kcore",
                "/proc/keys",
                "/proc/latency_stats",
                "/proc/timer_list",
                "/proc/timer_stats",
                "/proc/sched_debug",
                "/proc/scsi",
                "/sys/firmware"
            ],
            "ReadonlyPaths": [
                "/proc/bus",
                "/proc/fs",
                "/proc/irq",
                "/proc/sys",
                "/proc/sysrq-trigger"
            ]
        },
        "GraphDriver": {
            "Data": {
                "LowerDir": "/var/lib/docker/overlay2/729b8199271e8b8b1cb5414cf5ef1782a52108c66ff13f159dafabb16cc2f6f2-init/diff:/var/lib/docker/overlay2/4369da29b7531898a87fa64ffb034e6e1c91a30d1ed8e37c08bcfa2c4fc3a70e/diff",
                "MergedDir": "/var/lib/docker/overlay2/729b8199271e8b8b1cb5414cf5ef1782a52108c66ff13f159dafabb16cc2f6f2/merged",
                "UpperDir": "/var/lib/docker/overlay2/729b8199271e8b8b1cb5414cf5ef1782a52108c66ff13f159dafabb16cc2f6f2/diff",
                "WorkDir": "/var/lib/docker/overlay2/729b8199271e8b8b1cb5414cf5ef1782a52108c66ff13f159dafabb16cc2f6f2/work"
            },
            "Name": "overlay2"
        },
        "Mounts": [],
        "Config": {
            "Hostname": "21d8bc7c77b5",
            "Domainname": "",
            "User": "",
            "AttachStdin": true,
            "AttachStdout": true,
            "AttachStderr": true,
            "Tty": true,
            "OpenStdin": true,
            "StdinOnce": true,
            "Env": [
                "PATH=/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin"
            ],
            "Cmd": [
                "/bin/bash"
            ],
            "Image": "centos",
            "Volumes": null,
            "WorkingDir": "",
            "Entrypoint": null,
            "OnBuild": null,
            "Labels": {
                "org.label-schema.build-date": "20200114",
                "org.label-schema.license": "GPLv2",
                "org.label-schema.name": "CentOS Base Image",
                "org.label-schema.schema-version": "1.0",
                "org.label-schema.vendor": "CentOS",
                "org.opencontainers.image.created": "2020-01-14 00:00:00-08:00",
                "org.opencontainers.image.licenses": "GPL-2.0-only",
                "org.opencontainers.image.title": "CentOS Base Image",
                "org.opencontainers.image.vendor": "CentOS"
            }
        },
        "NetworkSettings": {
            "Bridge": "",
            "SandboxID": "c37d6af31fd2e464bc0f580aa47ea83db566d88d42820774e9e6d27e92d138ed",
            "HairpinMode": false,
            "LinkLocalIPv6Address": "",
            "LinkLocalIPv6PrefixLen": 0,
            "Ports": {},
            "SandboxKey": "/var/run/docker/netns/c37d6af31fd2",
            "SecondaryIPAddresses": null,
            "SecondaryIPv6Addresses": null,
            "EndpointID": "45b8e67f40e4395187e1adf19b227d9d7d46ca87a60e7fb08d5770c049af2be9",
            "Gateway": "172.17.0.1",
            "GlobalIPv6Address": "",
            "GlobalIPv6PrefixLen": 0,
            "IPAddress": "172.17.0.2",
            "IPPrefixLen": 16,
            "IPv6Gateway": "",
            "MacAddress": "02:42:ac:11:00:02",
            "Networks": {
                "bridge": {
                    "IPAMConfig": null,
                    "Links": null,
                    "Aliases": null,
                    "NetworkID": "e78edd4f399e8cb21117502229c99bc17e469f3a6e83a233b08f014cb32fe8ac",
                    "EndpointID": "45b8e67f40e4395187e1adf19b227d9d7d46ca87a60e7fb08d5770c049af2be9",
                    "Gateway": "172.17.0.1",
                    "IPAddress": "172.17.0.2",
                    "IPPrefixLen": 16,
                    "IPv6Gateway": "",
                    "GlobalIPv6Address": "",
                    "GlobalIPv6PrefixLen": 0,
                    "MacAddress": "02:42:ac:11:00:02",
                    "DriverOpts": null
                }
            }
        }
    }
]
```

## 总结

![img](http://img.zhaojishun.cn/img/%E4%B8%8B%E8%BD%BD.png)

`attach` Attach to a running container # 当前 shell 下 attach 连接指定运行镜像

`build` Build an image from a Dockerfile # 通过 Dockerfile 定制镜像

`commit` Create a new image from a container changes # 提交当前容器为新的镜像

`cp` Copy files/folders from the containers filesystem to the host path #从容器中拷贝指定文件或者目录到宿主机中

`create` Create a new container # 创建一个新的容器，同 run，但不启动容器

`diff` Inspect changes on a container's filesystem # 查看 docker 容器变化

`events` Get real time events from the server # 从 docker 服务获取容器实时事件

`exe`c Run a command in an existing container # 在已存在的容器上运行命令

`export` Stream the contents of a container as a tar archive # 导出容器的内容流作为一个 tar 归档文件[对应 import ]

`history` Show the history of an image # 展示一个镜像形成历史

`images` List images # 列出系统当前镜像

`import` Create a new filesystem image from the contents of a tarball # 从tar包中的内容创建一个新的文件系统映像[对应export]

`info` Display system-wide information # 显示系统相关信息

`inspect` Return low-level information on a container # 查看容器详细信息

`kill` Kill a running container # kill 指定 docker 容器

`load` Load an image from a tar archive # 从一个 tar 包中加载一个镜像[对应 save]

`login` Register or Login to the docker registry server # 注册或者登陆一个 docker 源服务器

`logout` Log out from a Docker registry server # 从当前 Docker registry 退出

`logs` Fetch the logs of a container # 输出当前容器日志信息

`port` Lookup the public-facing port which is NAT-ed to PRIVATE_PORT # 查看映射端口对应的容器内部源端口

`pause` Pause all processes within a container # 暂停容器

`ps` List containers # 列出容器列表

`pull` Pull an image or a repository from the docker registry server # 从docker镜像源服务器拉取指定镜像或者库镜像

`push` Push an image or a repository to the docker registry server # 推送指定镜像或者库镜像至docker源服务器

`restart` Restart a running container # 重启运行的容器

`rm` Remove one or more containers # 移除一个或者多个容器

`rmi` Remove one or more images # 移除一个或多个镜像[无容器使用该镜像才可删除，否则需删除相关容器才可继续或 -f 强制删除]

`run` Run a command in a new container # 创建一个新的容器并运行一个命令

`save` Save an image to a tar archive # 保存一个镜像为一个 tar 包[对应 load]

`search` Search for an image on the Docker Hub # 在 docker hub 中搜索镜像

`start` Start a stopped containers # 启动容器

`stop` Stop a running containers # 停止容器

`tag` Tag an image into a repository # 给源中镜像打标签

`top` Lookup the running processes of a container # 查看容器中运行的进程信息

`unpause` Unpause a paused container # 取消暂停容器

`version` Show the docker version information # 查看 docker 版本号

`wait` Block until a container stops, then print its exit code # 截取容器停止时的退出状态值

## 练习

> docker 安装启动nginx

```
[root@localhost ~]# docker images
REPOSITORY          TAG                 IMAGE ID            CREATED             SIZE
mysql               latest              a7a67c95e831        2 weeks ago         541MB
mysql               latest              a7a67c95e831        2 weeks ago         541MB
tomcat              latest              927899a31456        2 weeks ago         647MB
nginx               latest              602e111c06b6        3 weeks ago         127MB
centos              latest              470671670cac        3 months ago        237MB
hello-world         latest              bf756fb1ae65        4 months ago        13.3kB
[root@localhost ~]# docker run -d --name mynginx -p 9999:80 nginx
dab7d64d47a78863d7defd63080de53ae08e39babbba5e3b7b7cfafbb19a4aac
[root@localhost ~]# curl localhost:9999
<!DOCTYPE html>
<html>
<head>
<title>Welcome to nginx!</title>
<style>
    body {
        width: 35em;
        margin: 0 auto;
        font-family: Tahoma, Verdana, Arial, sans-serif;
    }
</style>
</head>
<body>
<h1>Welcome to nginx!</h1>
<p>If you see this page, the nginx web server is successfully installed and
working. Further configuration is required.</p>

<p>For online documentation and support please refer to
<a href="http://nginx.org/">nginx.org</a>.<br/>
Commercial support is available at
<a href="http://nginx.com/">nginx.com</a>.</p>

<p><em>Thank you for using nginx.</em></p>
</body>
</html>
```

> 安装tomcat

```
--rm 用完即删
docker run -it --rm tomcat:9.0
Unable to find image 'tomcat:9.0' locally
9.0: Pulling from library/tomcat
90fe46dd8199: Already exists 
35a4f1977689: Already exists 
bbc37f14aded: Already exists 
74e27dc593d4: Already exists 
93a01fbfad7f: Already exists 
35b994955649: Already exists 
7f9f18312a34: Already exists 
574205fe650b: Already exists 
35150a1638af: Pull complete 
c398e449144f: Pull complete 
Digest: sha256:989f0c7140d1af980e6c988c4780d962aa7431111de4757636dd12932401657b
Status: Downloaded newer image for tomcat:9.0
Using CATALINA_BASE:   /usr/local/tomcat
Using CATALINA_HOME:   /usr/local/tomcat
Using CATALINA_TMPDIR: /usr/local/tomcat/temp
Using JRE_HOME:        /usr/local/openjdk-11
Using CLASSPATH:       /usr/local/tomcat/bin/bootstrap.jar:/usr/local/tomcat/bin/tomcat-juli.jar
NOTE: Picked up JDK_JAVA_OPTIONS:  --add-opens=java.base/java.lang=ALL-UNNAMED --add-opens=java.base/java.io=ALL-UNNAMED --add-opens=java.rmi/sun.rmi.transport=ALL-UNNAMED
15-May-2020 07:01:00.112 INFO [main] org.apache.catalina.startup.VersionLoggerListener.log Server version name:   Apache Tomcat/9.0.35
15-May-2020 07:01:00.115 INFO [main] org.apache.catalina.startup.VersionLoggerListener.log Server built:          May 5 2020 20:36:20 UTC
15-May-2020 07:01:00.115 INFO [main] org.apache.catalina.startup.VersionLoggerListener.log Server version number: 9.0.35.0
15-May-2020 07:01:00.115 INFO [main] org.apache.catalina.startup.VersionLoggerListener.log OS Name:               Linux
15-May-2020 07:01:00.115 INFO [main] org.apache.catalina.startup.VersionLoggerListener.log OS Version:            3.10.0-1062.12.1.el7.x86_64


[root@localhost ~]# docker run -it -d -p:2222:3333 tomcat:9.0
82ab7ae512aebb44916ba1a98ed5ed2a4347d4918aa6debfa424c64ff9d205a5
[root@localhost ~]# docker ps
CONTAINER ID        IMAGE               COMMAND                  CREATED             STATUS              PORTS                              NAMES
82ab7ae512ae        tomcat:9.0          "catalina.sh run"        6 seconds ago       Up 4 seconds        8080/tcp, 0.0.0.0:2222->3333/tcp   brave_bell
dab7d64d47a7        nginx               "nginx -g 'daemon of…"   15 minutes ago      Up 15 minutes       0.0.0.0:9999->80/tcp               mynginx
21d8bc7c77b5        centos              "/bin/bash"              31 minutes ago      Up 31 minutes                                          determined_wiles
[root@localhost ~]# docker exec -it 82 /bin/bash
root@82ab7ae512ae:/usr/local/tomcat#
```

# Docker 镜像

## 是什么

> 镜像是一种轻量级、可执行的独立软件包，用来打包软件运行环境和基于运行环境开发的软件，它包含运行某个软件所需的所有内容，包括代码、运行时、库、环境变量和配置文件。

UnionFS（联合文件系统）：Union文件系统（UnionFS）是一种分层、轻量级并且高性能的文件系统，它支持对文件系统的修改作为一次提交来一层层的叠加，同时可以将不同目录挂载到同一个虚拟文件系统下(unite several directories into a single virtual filesystem)。Union 文件系统是 Docker 镜像的基础。镜像可以通过分层来进行继承，基于基础镜像（没有父镜像），可以制作各种具体的应用镜像。

## 镜像加载原理

> docker的镜像实际上由一层一层的文件系统组成，这种层级的文件系统UnionFS。
>
> bootfs(boot file system)主要包含bootloader和kernel, bootloader主要是引导加载kernel, Linux刚启动时会加载bootfs文件系统，在Docker镜像的最底层是bootfs。这一层与我们典型的Linux/Unix系统是一样的，包含boot加载器和内核。当boot加载完成之后整个内核就都在内存中了，此时内存的使用权已由bootfs转交给内核，此时系统也会卸载bootfs。
>
> rootfs (root file system) ，在bootfs之上。包含的就是典型 Linux 系统中的 /dev, /proc, /bin, /etc 等标准目录和文件。rootfs就是各种不同的操作系统发行版，比如Ubuntu，Centos等等。

![image-20200512104752689](http://img.zhaojishun.cn/img/image-20200512104752689.png)

对于一个精简的OS，rootfs可以很小，只需要包括最基本的命令、工具和程序库就可以了，因为底层直接用Host的kernel，自己只需要提供 rootfs 就行了。由此可见对于不同的linux发行版, bootfs基本是一致的, rootfs会有差别, 因此不同的发行版可以公用bootfs。

## 镜像的分层

以我们的pull为例，在下载的过程中我们可以看到docker的镜像好像是在一层一层的在下载

![image-20200512104844102](http://img.zhaojishun.cn/img/image-20200512104844102.png)

使用分层接口的好处

最大的一个好处就是 - 共享资源

比如：有多个镜像都从相同的 base 镜像构建而来，那么宿主机只需在磁盘上保存一份base镜像，

同时内存中也只需加载一份 base 镜像，就可以为所有容器服务了。而且镜像的每一层都可以被共享。

## 特点

Docker镜像都是只读的

当容器启动时，**一个新的可写层被加载到镜像的顶部。**

这一层通常被称作“容器层”，“容器层”之下的都叫“镜像层”。

## commit 镜像

```
docker commit 提交容器为一个新的副本
docker commit -m"本次提交信息" -a"作者" 容器id 提交镜像名[:tag]
# 1、启动一个默认的tomcat
[root@localhost ~]# docker run -itd -p:8080:8080 tomcat:9.0
98b1fde6bd4b42c11bb37498a9aafe6f71503c43ce24954ce3d8e009e0bb07c8
[root@localhost ~]# docker exec -it 98 /bin/bash
root@98b1fde6bd4b:/usr/local/tomcat# ls
BUILDING.txt	 LICENSE  README.md	 RUNNING.txt  conf  logs	    temp     webapps.dist
CONTRIBUTING.md  NOTICE   RELEASE-NOTES  bin	      lib   native-jni-lib  webapps  work
# 2、修改镜像
root@98b1fde6bd4b:/usr/local/tomcat# cp -r webapps.dist/* webapps
root@98b1fde6bd4b:/usr/local/tomcat# cd webapps
root@98b1fde6bd4b:/usr/local/tomcat/webapps# ls
ROOT  docs  examples  host-manager  manager
root@98b1fde6bd4b:/usr/local/tomcat/webapps# curl localhost:8080

<!DOCTYPE html>
<html lang="en">
  //内容太多不展示了
</html>
# 3、提交镜像
[root@localhost ~]# docker commit -m"add webapp" -a"zhao" 98b1fde6bd4b tomcatzhao:1.0
sha256:1891f2c19c632713ef496c7e0e95ca0ee1563c0a836513002ebb439ecd988d2a
[root@localhost ~]# docker images
REPOSITORY          TAG                 IMAGE ID            CREATED             SIZE
tomcatzhao          1.0                 1891f2c19c63        10 minutes ago      652MB
tomcat              9.0                 d03312117bb0        2 days ago          647MB
redis               latest              f9b990972689        13 days ago         104MB
mysql               latest              a7a67c95e831        2 weeks ago         541MB
mysql               latest              a7a67c95e831        2 weeks ago         541MB
tomcat              latest              927899a31456        2 weeks ago         647MB
nginx               latest              602e111c06b6        3 weeks ago         127MB
centos              latest              470671670cac        3 months ago        237MB
hello-world         latest              bf756fb1ae65        4 months ago        13.3kB
```

# 容器数据卷

## 是什么

- 将运用与运行的环境打包形成容器运行 ，运行可以伴随着容器，但是我们对数据的要求希望是`持久化`的
- 容器之间希望有可`能共享数据`

Docker容器产生的数据，如果不通过docker commit生成新的镜像，使得数据做为镜像的一部分保存下来，

那么当`容器删除后`，`数据`自然也就`没有`了。

为了能保存数据在docker中我们使用容器数据卷。

## 能干什么

卷就是目录或文件，存在于一个或多个容器中，由docker挂载到容器，但不属于联合文件系统，因此能够绕过Union File System提供一些用于持续存储或共享数据的特性：

卷的设计目的就是数据的`持久化`，完全独立于容器的生存周期，因此`Docker不会在容器删除时删除其挂载的数据卷`

特点：

1：数据卷可在容器之间`共享或重用数据`

2：卷中的`更改可以直接生效`

3：数据卷中的更改不会包含在镜像的更新中

4：数据卷的生命周期一直持续到没有容器使用它为止

5：容器和宿主机之间数据共享

6：容器停止后，主机修改数据后数据同步

## 创建一个数据卷 `--mount`

```
docker volume create myvolume
[root@localhost home]# docker volume create myvolume
myvolume
```

### 查看所有数据卷

```
docker volume ls
[root@localhost home]# docker volume ls
DRIVER              VOLUME NAME
local               myvolume
```

### 查看指定数据卷的信息

```
docker volume inspect myvolume 
[root@localhost home]# docker volume inspect myvolume 
[
    {
        "CreatedAt": "2020-05-15T19:31:08-07:00",
        "Driver": "local",
        "Labels": {},
        "Mountpoint": "/var/lib/docker/volumes/myvolume/_data",
        "Name": "myvolume",
        "Options": {},
        "Scope": "local"
    }
]
```

### 启动一个挂载数据卷的容器

在用 `docker run` 命令的时候，使用 `--mount` 标记来将 `数据卷` 挂载到容器里。在一次 `docker run` 中可以挂载多个 `数据卷`。

```
[root@localhost home]# docker run -itd --mount source=myvloume,target=/test/ centos /bin/bash
c2faa631c5a5efc7a5a250527be564252ab233338c5d2e0ccfe983538010dc7d
[root@localhost home]# docker ps
CONTAINER ID        IMAGE               COMMAND             CREATED              STATUS              PORTS               NAMES
c2faa631c5a5        centos              "/bin/bash"         4 seconds ago        Up 3 seconds                            epic_haibt
0a11c340d3a5        centos              "/bin/bash"         About a minute ago   Up About a minute                       tender_einstein
[root@localhost home]# docker exec c2 /bin/bash
[root@localhost home]# docker exec -it c2 /bin/bash
[root@c2faa631c5a5 /]# ls
bin  dev  etc  home  lib  lib64  lost+found  media  mnt  opt  proc  root  run  sbin  srv  sys  test  tmp  usr  var
```

### 删除数据卷

```
docker volume rm volumeName
[root@localhost home]# docker volume rm myvolume
myvolume
```

`数据卷` 是被设计用来持久化数据的，它的生命周期独立于容器，Docker 不会在容器被删除后自动删除 `数据卷`，并且也不存在垃圾回收这样的机制来处理没有任何容器引用的 `数据卷`。如果需要在删除容器的同时移除数据卷。可以在删除容器的时候使用 `docker rm -v` 这个命令。

无主的数据卷可能会占据很多空间，要清理请使用以下命令

```
$ docker volume prune
```

### 挂载主机目录作为数据卷

使用 `--mount` 标记可以指定挂载一个本地主机的目录到容器中去。

```
docker run -itd --mount type=bind,source=/home,target=/test/home centos /bin/bash
```

上面的命令加载主机的 `/home` 目录到容器的 `/test/home`目录。这个功能在进行测试的时候十分方便，比如用户可以放置一些程序到本地目录中，来查看容器是否正常工作。本地目录的路径必须是绝对路径，以前使用 `-v` 参数时如果本地目录不存在 Docker 会自动为你创建一个文件夹，现在使用 `--mount` 参数时如果本地目录不存在，Docker 会报错。

> 测试文件显示

```
宿主机
[root@localhost home]# cd /home/
[root@localhost home]# ls
threefloorsingin-1.0-SNAPSHOT-jar-with-dependencies.jar  zhaojishun

docker容器
[root@0a0f80449f1d /]# cd test/home/
[root@0a0f80449f1d home]# ls
threefloorsingin-1.0-SNAPSHOT-jar-with-dependencies.jar  zhaojishun
```

> 测试文件写入

```
docker容器
[root@0a0f80449f1d home]# touch test.java
[root@0a0f80449f1d home]# ls
test.java  threefloorsingin-1.0-SNAPSHOT-jar-with-dependencies.jar  zhaojishun

宿主机
[root@localhost home]# ls
test.java  threefloorsingin-1.0-SNAPSHOT-jar-with-dependencies.jar  zhaojishun
```

Docker 挂载主机目录的默认权限是 `读写`，用户也可以通过增加 `readonly` 指定为 `只读`。

```
docker run -itd --mount type=bind,source=/home,target=/test/home,readonly centos /bin/bash
```

加了 `readonly` 之后，就挂载为 `只读` 了。如果你在容器内 `/test/home` 目录新建文件，会显示如下错误

```
/test/home # touch new.txt
touch: new.txt: Read-only file system
```

## 为容器添加数据卷 `-v`

```
docker run -it -v /宿主机目录:/容器内目录 centos /bin/bash

[root@localhost ~]# docker run -it -v /home/zhaojishun/:/home centos /bin/bash
## 宿主机 被挂载的目录如果不存在会自动创建
[root@localhost ~]# cd /home/
[root@localhost home]# ls
zhaojishun
## 通过docker inspect 查看容器挂载情况
docker inspect f88d14b4b0af
```

![image-20200519192621325](http://img.zhaojishun.cn/img/image-20200519192621325.png)

> 测试数据双向同步

![image-20200519194242777](http://img.zhaojishun.cn/img/image-20200519194242777.png)

### 查看是否挂载成功

```
docker inspect 容器ID
"Mounts": [
            {
                "Type": "volume",
                "Name": "myvloume",
                "Source": "/var/lib/docker/volumes/myvloume/_data",
                "Destination": "/test",
                "Driver": "local",
                "Mode": "z",
                "RW": true,
                "Propagation": ""
            }
        ],
```

### 设置读写权限

```
# 通过容器内路径 -v 容器内路径:ro  rw 改变读写权限
ro 只读
rw 可读可写（默认）

# 一旦设置了权限，容器对挂载出来的内容就有限定
docker run -d -P --name mynginx01 -v /etc/nginx:ro nginx
docker run -d -P --name mynginx01 -v /etc/nginx:rw nginx
```

## 具名挂载与匿名挂载

```
# 匿名挂载
[root@localhost ~]# docker run -d -P --name mynginx01 -v /etc/nginx nginx
50c23aab58135b80f86032644e18a5f2f30b0a7779bc4433684a1c0204b974a4

# 查看所有卷的情况
[root@localhost ~]# docker volume ls
DRIVER              VOLUME NAME
local               19d6ee71811d081280f72184a68a85bba9aa460242143ee6e1447a64fe44c917

# 这种就是匿名挂载，在-v时只指定了容器内的路径，没有写容器外的路径
# 查看容器元数据
docker inspect mynginx01

"Mounts": [
            {
                "Type": "volume",
                "Name": "19d6ee71811d081280f72184a68a85bba9aa460242143ee6e1447a64fe44c917",
                "Source": "/var/lib/docker/volumes/19d6ee71811d081280f72184a68a85bba9aa460242143ee6e1447a64fe44c917/_data",
                "Destination": "/etc/nginx",
                "Driver": "local",
                "Mode": "",
                "RW": true,
                "Propagation": ""
            }
        ],
        
        
# 具名挂载 
# 通过 -v 卷名:/容器内路径
[root@localhost ~]# docker run -d -P --name mynginx02 -v juming:/etc/nginx nginx
c8b794fc75d5db0d837ff5dbbe1eeeb1998156414479cf43952f97a68f232e45
[root@localhost ~]# docker volume ls
DRIVER              VOLUME NAME
local               19d6ee71811d081280f72184a68a85bba9aa460242143ee6e1447a64fe44c917
local               juming

# 查看数据卷
docker volume inspect juming

[
    {
        "CreatedAt": "2020-05-19T05:33:01-07:00",
        "Driver": "local",
        "Labels": null,
        "Mountpoint": "/var/lib/docker/volumes/juming/_data",
        "Name": "juming",
        "Options": null,
        "Scope": "local"
    }
]
```

> 所有的数据卷都在`/var/lib/docker/volumes/volumeName/_data`下
>
> 通过具名挂载可以很方便的找到一个卷，大多数情况下用`具名挂载`

```
# 如何确定是匿名挂载还是具名挂载
-v 容器内路径 			# 匿名挂载 使用dockerfile生成的镜像是匿名挂载
-v 卷名:/容器内路径 	   #具名挂载
-v /宿主机路径:/容器内路径 #指定路径挂载
```

## 数据卷容器

> 命名的容器挂载数据卷，其它容器通过挂载这个(父容器)实现数据共享，挂载数据卷的容器，称之为数据卷容器，可以实现多个容器间数据共享。
>
> ```
> --volumes-from 容器名
> ```

```
docker run -itd -p 9090:8080 --volumes-from tomcat_1 --name tomcat_2 tomcat
```

![image-20200516111508482](http://img.zhaojishun.cn/img/image-20200516111508482.png)

结论：容器之间配置信息的传递，数据卷的生命周期一直持续到没有容器使用它为止

## 实战：安装mysql

> 解决mysql 数据持久化

```
# 获取镜像
[root@localhost ~]# docker pull mysql:5.7

# 运行容器：映射端口 挂载配置文件和数据文件 设置密码 
# docker run -p 3306:3306 --name mysql -v /home/mysql/conf:/etc/mysql/conf.d -v /home/mysql/data/:/var/lib/mysql -e MYSQL_ROOT_PASSWORD=123456 -d imageID

# 启动容器
-d 后台运行
-p 端口映射
-v 挂载数据卷 
-e 环境配置
-name 名称
[root@localhost ~]# docker run -p 3306:3306 --name mysql -v /home/mysql/conf:/etc/mysql/conf.d -v /home/mysql/data/:/var/lib/mysql -e MYSQL_ROOT_PASSWORD=123456 -d b84d68d0a7db
```

> 本地链接成功

![image-20200519200735564](http://img.zhaojishun.cn/img/image-20200519200735564.png)

> 测试创建数据库，查看宿主机挂载目录

![image-20200519201425834](http://img.zhaojishun.cn/img/image-20200519201425834.png)

![image-20200519201528369](http://img.zhaojishun.cn/img/image-20200519201528369.png)

> 测试删除容器后宿主机目录

```
[root@localhost ~]# docker ps
CONTAINER ID        IMAGE               COMMAND                  CREATED           STATUS              PORTS                               NAMES
cd4b68f4594c        b84d68d0a7db        "docker-entrypoint.s…"   11 minutes ago      Up 11 minutes       0.0.0.0:3306->3306/tcp, 33060/tcp   mysql
[root@localhost ~]# docker rm -f mysql
mysql
[root@localhost ~]# docker ps
CONTAINER ID        IMAGE               COMMAND             CREATED             STATUS              PORTS               NAMES
```

**mysql已经无法链接**

![image-20200519201957835](http://img.zhaojishun.cn/img/image-20200519201957835.png)

**宿主机目录依旧存在**

![image-20200519201739687](http://img.zhaojishun.cn/img/image-20200519201739687.png)

> **测试启动新mysql挂载相同目录**

```
[root@localhost data]# docker run -p 3306:3306 --name mysql -v /home/mysql/conf:/etc/mysql/conf.d -v /home/mysql/data/:/var/lib/mysql -e MYSQL_ROOT_PASSWORD=123456 -d b84d68d0a7db
2349862deb6234aa934f8a5da6095f1966024039b8dec4c337380a6c7180da4c
```

**数据没丢失**

![image-20200519202135292](http://img.zhaojishun.cn/img/image-20200519202135292.png)

# Dockerfile 定制镜像

从刚才的 `docker commit` 的学习中，我们可以了解到，镜像的定制实际上就是定制每一层所添加的配置、文件。如果我们可以把每一层修改、安装、构建、操作的命令都写入一个脚本，用这个脚本来构建、定制镜像，那么之前提及的无法重复的问题、镜像构建透明性的问题、体积的问题就都会解决。这个脚本就是 Dockerfile。

Dockerfile 是一个文本文件，其内包含了一条条的 **指令(Instruction)**，每一条指令构建一层，因此每一条指令的内容，就是描述该层应当如何构建。

dockerFile --> docker build --> docker run

## 基础知识

1：每条保留字指令都必须为大写字母且后面要跟随至少一个参数

2：指令按照从上到下，顺序执行

3：#表示注释

4：每条指令都会创建一个新的镜像层，并对镜像进行提交

**总结**

从应用软件的角度来看，Dockerfile、Docker镜像与Docker容器分别代表软件的三个不同阶段，

\* Dockerfile是软件的原材料

\* Docker镜像是软件的交付品

\* Docker容器则可以认为是软件的运行态。

Dockerfile面向开发，Docker镜像成为交付标准，Docker容器则涉及部署与运维，三者缺一不可，合力充当Docker体系的基石。

![image-20200516113629674](http://img.zhaojishun.cn/img/image-20200516113629674.png)

1 Dockerfile，需要定义一个Dockerfile，Dockerfile定义了进程需要的一切东西。Dockerfile涉及的内容包括执行代码或者是文件、环境变量、依赖包、运行时环境、动态链接库、操作系统的发行版、服务进程和内核进程(当应用进程需要和系统服务和内核进程打交道，这时需要考虑如何设计namespace的权限控制)等等;

2 Docker镜像，在用Dockerfile定义一个文件之后，docker build时会产生一个Docker镜像，当运行 Docker镜像时，会真正开始提供服务;

3 Docker容器，容器是直接提供服务的。

## 构建过程

（1）docker从基础镜像运行一个容器

（2）执行一条指令并对容器作出修改

（3）执行类似docker commit的操作提交一个新的镜像层

（4）docker再基于刚提交的镜像运行一个新容器

（5）执行dockerfile中的下一条指令直到所有指令都执行完成

## 基本结构

一般的，Dockerfile 分为四部分：`基础镜像信息`、`维护者信息`、`镜像操作指令`和`容器启动时执行指令`。

例如

```
# This dockerfile uses the ubuntu image
# VERSION 2 - EDITION 1
# Author: docker_user
# Command format: Instruction [arguments / command] ..

# Base image to use, this must be set as the first line
FROM ubuntu

# Maintainer: docker_user <docker_user at email.com> (@docker_user)
MAINTAINER docker_user docker_user@email.com

# Commands to update the image
RUN echo "deb http://archive.ubuntu.com/ubuntu/ raring main universe" >> /etc/apt/sources.list
RUN apt-get update && apt-get install -y nginx
RUN echo "\ndaemon off;" >> /etc/nginx/nginx.conf

# Commands when creating a new container
CMD /usr/sbin/nginx
```

其中，一开始必须指明所基于的镜像名称，接下来推荐说明维护者信息。

后面则是镜像操作指令，例如 `RUN` 指令，`RUN` 指令将对镜像执行跟随的命令。每运行一条 `RUN` 指令，镜像添加新的一层，并提交。

最后是 `CMD` 指令，来指定运行容器时的操作命令。

## 指令

```shell
FROM			#基础镜像，一切在这里构建
MAINTAINER		#镜像是谁写的
RUN				#镜像构建时需要执行的命令
ADD				#添加本地文件到镜像内，压缩文件会自动解压
WORKDIR			#当前工作目录
VOLUME			#挂载的目录
EXPOSE			#暴露的端口
RUN				#
CMD 			#指定容器启动时要执行的命令，只有最后一个命令会生效，可悲替代
ENTRYPOINT 		#指定容器启动时要执行的命令，可以追加命令
COPY			#类似add命令，将文件拷贝到镜像中
ENV				#设置环境变量
```

![image-20200516114144590](http://img.zhaojishun.cn/img/image-20200516114144590.png)

## 实战测试

### 为centos镜像添加vim和ifconfig功能

```
[root@0a0f80449f1d home]# vim      
bash: vim: command not found
[root@0a0f80449f1d home]# ifconfig
bash: ifconfig: command not found

# 默认的centos镜像没有vim和ifconfig命令

# 编写dockerfile

FROM centos
MAINTAINER shun<fzjs@qq.com>

ENV MYPATH /usr/local
WORKDIR $MYPATH

RUN yum -y install vim
RUN yum -y install net-toos

EXPORT 80

CMD echo $MYPATH
CMD echo "builder end"
CMD /bin/bash

# 通过文件构建镜像
docker build -f dockerfile文件路径 -t 镜像名:tag .

[root@localhost docker]# docker build -f mycentosdockerfile -t zhaocentos:0.1 .
Sending build context to Docker daemon  2.048kB
Step 1/10 : FROM centos
 ---> 470671670cac
Step 2/10 : MAINTAINER shun<fzjs@qq.com>
 ---> Using cache
 ---> 066b4586e5d6
Step 3/10 : ENV MYPATH /usr/local
 ---> Using cache
 ---> eff8ceb8abf4
Step 4/10 : WORKDIR $MYPATH
 ---> Using cache
 ---> eebf78750a7e
Step 5/10 : RUN yum -y install vim
 ---> Using cache
 ---> 265f35673055
Step 6/10 : RUN yum -y install net-tools
 ---> Running in 676d491d475f
Last metadata expiration check: 0:00:55 ago on Sat May 16 04:14:05 2020.
Dependencies resolved.
================================================================================
 Package         Architecture Version                        Repository    Size
================================================================================
Installing:
 net-tools       x86_64       2.0-0.51.20160912git.el8       BaseOS       323 k

Transaction Summary
================================================================================
Install  1 Package

Total download size: 323 k
Installed size: 1.0 M
Downloading Packages:
net-tools-2.0-0.51.20160912git.el8.x86_64.rpm   415 kB/s | 323 kB     00:00    
--------------------------------------------------------------------------------
Total                                           272 kB/s | 323 kB     00:01     
Running transaction check
Transaction check succeeded.
Running transaction test
Transaction test succeeded.
Running transaction
  Preparing        :                                                        1/1 
  Installing       : net-tools-2.0-0.51.20160912git.el8.x86_64              1/1 
  Running scriptlet: net-tools-2.0-0.51.20160912git.el8.x86_64              1/1 
  Verifying        : net-tools-2.0-0.51.20160912git.el8.x86_64              1/1 

Installed:
  net-tools-2.0-0.51.20160912git.el8.x86_64                                     

Complete!
Removing intermediate container 676d491d475f
 ---> 2271b537f9c8
Step 7/10 : EXPOSE 80
 ---> Running in 28a23ff77e24
Removing intermediate container 28a23ff77e24
 ---> 1ef425ba0e54
Step 8/10 : CMD echo $MYPATH
 ---> Running in 6c4812974993
Removing intermediate container 6c4812974993
 ---> 57c43bb33f1a
Step 9/10 : CMD echo "builder end"
 ---> Running in 47008f6ea4d4
Removing intermediate container 47008f6ea4d4
 ---> 25f8fc3dabf0
Step 10/10 : CMD /bin/bash
 ---> Running in 14586c4fa37c
Removing intermediate container 14586c4fa37c
 ---> 862fa5567b2d
Successfully built 862fa5567b2d
Successfully tagged zhaocentos:0.1

# 查看构建的镜像
[root@localhost docker]# docker images
REPOSITORY          TAG                 IMAGE ID            CREATED             SIZE
zhaocentos          0.1                 862fa5567b2d        2 minutes ago       321MB

# 测试安装命令
[root@localhost docker]# docker run -it 862fa5567b2d
[root@7c12fd1ef150 local]# ifconfig
eth0: flags=4163<UP,BROADCAST,RUNNING,MULTICAST>  mtu 1500
        inet 172.17.0.5  netmask 255.255.0.0  broadcast 172.17.255.255
        ether 02:42:ac:11:00:05  txqueuelen 0  (Ethernet)
        RX packets 8  bytes 656 (656.0 B)
        RX errors 0  dropped 0  overruns 0  frame 0
        TX packets 0  bytes 0 (0.0 B)
        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0

lo: flags=73<UP,LOOPBACK,RUNNING>  mtu 65536
        inet 127.0.0.1  netmask 255.0.0.0
        loop  txqueuelen 1000  (Local Loopback)
        RX packets 0  bytes 0 (0.0 B)
        RX errors 0  dropped 0  overruns 0  frame 0
        TX packets 0  bytes 0 (0.0 B)
        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0

# 查看设置的工作目录
[root@7c12fd1ef150 local]# pwd
/usr/local
```

**对比**

原生centos镜像

![image-20200516122151826](http://img.zhaojishun.cn/img/image-20200516122151826.png)

自己构建的镜像

![image-20200516122249191](http://img.zhaojishun.cn/img/image-20200516122249191.png)

#### 查看镜像的变更历史

```shell
[root@localhost docker]# docker history 862fa5567b2d
IMAGE               CREATED             CREATED BY                                      SIZE                COMMENT
862fa5567b2d        11 minutes ago      /bin/sh -c #(nop)  CMD ["/bin/sh" "-c" "/bin…   0B                  
25f8fc3dabf0        11 minutes ago      /bin/sh -c #(nop)  CMD ["/bin/sh" "-c" "echo…   0B                  
57c43bb33f1a        11 minutes ago      /bin/sh -c #(nop)  CMD ["/bin/sh" "-c" "echo…   0B                  
1ef425ba0e54        11 minutes ago      /bin/sh -c #(nop)  EXPOSE 80                    0B                  
2271b537f9c8        11 minutes ago      /bin/sh -c yum -y install net-tools             24MB                
265f35673055        12 minutes ago      /bin/sh -c yum -y install vim                   59.8MB              
eebf78750a7e        12 minutes ago      /bin/sh -c #(nop) WORKDIR /usr/local            0B                  
eff8ceb8abf4        12 minutes ago      /bin/sh -c #(nop)  ENV MYPATH=/usr/local        0B                  
066b4586e5d6        12 minutes ago      /bin/sh -c #(nop)  MAINTAINER shun<fzjs@qq.c…   0B                  
470671670cac        3 months ago        /bin/sh -c #(nop)  CMD ["/bin/bash"]            0B                  
<missing>           3 months ago        /bin/sh -c #(nop)  LABEL org.label-schema.sc…   0B                  
<missing>           4 months ago        /bin/sh -c #(nop) ADD file:aa54047c80ba30064…   237MB
```

### CMD 与 ENTRYPOINT 区别

```
CMD` Dockerfile 中可以有多个 CMD 指令，但只有最后一个生效，`CMD 会被 docker run 之后的参数替换
```

`ENTRYPOINT` 指定容器启动时要执行的命令，可以追加命令

```
# 创建dockerfile

FROM centos
CMD ["ls","-a"]

[root@iz2ze0yjvopoflqge64bg7z docker]# docker images
REPOSITORY          TAG                 IMAGE ID            CREATED             SIZE
cmdtest             latest              f40b1d5c1026        12 seconds ago      237MB

# 运行run命令 发现ls -a 生效
[root@iz2ze0yjvopoflqge64bg7z docker]# docker run cmdtest
.
..
.dockerenv
bin
dev
etc
home
lib
lib64
lost+found
media
mnt
opt
proc
root
run
sbin
srv
sys
tmp
usr
var

# 测试追加命令
[root@iz2ze0yjvopoflqge64bg7z docker]# docker run cmdtest -l
docker: Error response from daemon: OCI runtime create failed: container_linux.go:349: starting container process caused "exec: \"-l\": executable file not found in $PATH": unknown.
ERRO[0000] error waiting for container: context canceled 

# 追加的命令替换掉了cmd ，由于-l不是命令所以出错
[root@iz2ze0yjvopoflqge64bg7z docker]# docker run cmdtest ls -a -l
total 56
drwxr-xr-x   1 root root 4096 May 20 02:13 .
drwxr-xr-x   1 root root 4096 May 20 02:13 ..
-rwxr-xr-x   1 root root    0 May 20 02:13 .dockerenv
lrwxrwxrwx   1 root root    7 May 11  2019 bin -> usr/bin
drwxr-xr-x   5 root root  340 May 20 02:13 dev
drwxr-xr-x   1 root root 4096 May 20 02:13 etc
drwxr-xr-x   2 root root 4096 May 11  2019 home
lrwxrwxrwx   1 root root    7 May 11  2019 lib -> usr/lib
lrwxrwxrwx   1 root root    9 May 11  2019 lib64 -> usr/lib64
drwx------   2 root root 4096 Jan 13 21:48 lost+found
drwxr-xr-x   2 root root 4096 May 11  2019 media
drwxr-xr-x   2 root root 4096 May 11  2019 mnt
drwxr-xr-x   2 root root 4096 May 11  2019 opt
dr-xr-xr-x 106 root root    0 May 20 02:13 proc
dr-xr-x---   2 root root 4096 Jan 13 21:49 root
drwxr-xr-x  11 root root 4096 Jan 13 21:49 run
lrwxrwxrwx   1 root root    8 May 11  2019 sbin -> usr/sbin
drwxr-xr-x   2 root root 4096 May 11  2019 srv
dr-xr-xr-x  13 root root    0 May 20 02:13 sys
drwxrwxrwt   7 root root 4096 Jan 13 21:49 tmp
drwxr-xr-x  12 root root 4096 Jan 13 21:49 usr
drwxr-xr-x  20 root root 4096 Jan 13 21:49 var

## 创建dockerfile
FROM centos
ENTRYPOINT ["ls","-a"]

## 构建镜像
[root@iz2ze0yjvopoflqge64bg7z docker]# docker build -f docker-entrypoint -t entrypoint-test .
Sending build context to Docker daemon  3.072kB
Step 1/2 : FROM centos
 ---> 470671670cac
Step 2/2 : ENTRYPOINT ["ls","-a"]
 ---> Running in 414227fac4a0
Removing intermediate container 414227fac4a0
 ---> 263db1619eb0
Successfully built 263db1619eb0
Successfully tagged entrypoint-test:latest

## 启动镜像 
[root@iz2ze0yjvopoflqge64bg7z docker]# docker run entrypoint-test
.
..
.dockerenv
bin
dev
etc
home
lib
lib64
lost+found
media
mnt
opt
proc
root
run
sbin
srv
sys
tmp
usr
var

## 测试追加命令
[root@iz2ze0yjvopoflqge64bg7z docker]# docker run entrypoint-test -l
total 56
drwxr-xr-x   1 root root 4096 May 20 02:31 .
drwxr-xr-x   1 root root 4096 May 20 02:31 ..
-rwxr-xr-x   1 root root    0 May 20 02:31 .dockerenv
lrwxrwxrwx   1 root root    7 May 11  2019 bin -> usr/bin
drwxr-xr-x   5 root root  340 May 20 02:31 dev
drwxr-xr-x   1 root root 4096 May 20 02:31 etc
drwxr-xr-x   2 root root 4096 May 11  2019 home
lrwxrwxrwx   1 root root    7 May 11  2019 lib -> usr/lib
lrwxrwxrwx   1 root root    9 May 11  2019 lib64 -> usr/lib64
drwx------   2 root root 4096 Jan 13 21:48 lost+found
drwxr-xr-x   2 root root 4096 May 11  2019 media
drwxr-xr-x   2 root root 4096 May 11  2019 mnt
drwxr-xr-x   2 root root 4096 May 11  2019 opt
dr-xr-xr-x 105 root root    0 May 20 02:31 proc
dr-xr-x---   2 root root 4096 Jan 13 21:49 root
drwxr-xr-x  11 root root 4096 Jan 13 21:49 run
lrwxrwxrwx   1 root root    8 May 11  2019 sbin -> usr/sbin
drwxr-xr-x   2 root root 4096 May 11  2019 srv
dr-xr-xr-x  13 root root    0 May 20 02:31 sys
drwxrwxrwt   7 root root 4096 Jan 13 21:49 tmp
drwxr-xr-x  12 root root 4096 Jan 13 21:49 usr
drwxr-xr-x  20 root root 4096 Jan 13 21:49 var
```

## 创建并使用dockerfile将jar文件构建成镜像

```
FROM openjdk:8-jdk-alpine
MAINTAINER "120@qq.com <email>"
LABEL description="test app"
WORKDIR app
ADD cdata.jar /app/cdata.jar
EXPOSE 8080
CMD java -jar /app/cdata.jar
```

构建docker镜像

```
docker build .
```

# Docker 网络

## 理解Docker0

`ip addr`查看网络配置

![image-20200520104226178](http://img.zhaojishun.cn/img/image-20200520104226178.png)

> 三个网络

docker是如何处理网络访问的？

![image-20200520104359787](http://img.zhaojishun.cn/img/image-20200520104359787.png)

```
[root@iz2ze0yjvopoflqge64bg7z docker]# docker run -P --name tomcat02 tomcat

# 查看容器内部网络地址
[root@iz2ze0yjvopoflqge64bg7z docker]# docker exec tomcat02 ip addr
1: lo: <LOOPBACK,UP,LOWER_UP> mtu 65536 qdisc noqueue state UNKNOWN group default qlen 1
    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00
    inet 127.0.0.1/8 scope host lo
       valid_lft forever preferred_lft forever
       
28: eth0@if29: <BROADCAST,MULTICAST,UP,LOWER_UP> mtu 1500 qdisc noqueue state UP group default 
    link/ether 02:42:ac:12:00:02 brd ff:ff:ff:ff:ff:ff link-netnsid 0
    inet 172.18.0.2/16 brd 172.18.255.255 scope global eth0
       valid_lft forever preferred_lft forever
       
## 宿主机能否通过容器ip ping通容器内部？ 
[root@iz2ze0yjvopoflqge64bg7z docker]# ping 172.18.0.2
PING 172.18.0.2 (172.18.0.2) 56(84) bytes of data.
64 bytes from 172.18.0.2: icmp_seq=1 ttl=64 time=0.108 ms
64 bytes from 172.18.0.2: icmp_seq=2 ttl=64 time=0.081 ms

## 宿主机可以ping通docker容器内部
```

1. 每启动一个docker容器，docker就会给容器分配一个ip，只要安装了docker就会有一个网卡docker0

桥接模式，使用的技术是 evth-pair 技术

宿主机再次测试ip addr

![image-20200520105150966](http://img.zhaojishun.cn/img/image-20200520105150966.png)

1. 再启动一个tomcat ， 发现多了一对网卡

```
[root@iz2ze0yjvopoflqge64bg7z docker]# docker run -P -d --name tomcat03 tomcat
```

容器内部网卡信息

![image-20200520105457197](http://img.zhaojishun.cn/img/image-20200520105457197.png)

宿主机网卡信息

![image-20200520105426827](http://img.zhaojishun.cn/img/image-20200520105426827.png)

- 我们发现容器的网卡都是成对出现的
- evth-pair就是一对虚拟设备接口，他们都是成对出现的，一端连着协议，一段彼此相连
- 正因为有这个特性evth-pair充当一个桥梁，链接各种虚拟网络设备

1. 测试两个容器能否互相ping通？

```
# tomcat02 ip 172.18.0.2  tomcat03 ip 172.18.0.3
[root@iz2ze0yjvopoflqge64bg7z docker]# docker exec tomcat02 ping 172.18.0.3
PING 172.18.0.3 (172.18.0.3) 56(84) bytes of data.
64 bytes from 172.18.0.3: icmp_seq=1 ttl=64 time=0.146 ms
64 bytes from 172.18.0.3: icmp_seq=2 ttl=64 time=0.095 ms
64 bytes from 172.18.0.3: icmp_seq=3 ttl=64 time=0.097 ms
```

**结论：容器和容器之间可以正常ping通**

**网络模型图**

![image-20200520175345529](http://img.zhaojishun.cn/img/image-20200520175345529.png)

结论：tomcat02和tomcat03是公用的一个路由器docker0

所有的容器在不指定网络的情况下，都是docker0路由的，docker会给我们的容器分配一个默认的可用ip

> docker使用的是linux桥接，宿主机中是一个docker网桥docker0

![image-20200520180212533](http://img.zhaojishun.cn/img/image-20200520180212533.png)

docker中的网络接口都是虚拟的。只要容器删除对应网桥一对就没了

## --link（不推荐）

> 思考场景，编写了一个微服务，databases：url=ip，项目不重启，数据库ip换掉了，我们希望处理这个问题，可以通过名字来进行访问容器？

```
[root@iz2ze0yjvopoflqge64bg7z docker]# docker exec tomcat02 ping tomcat03
ping: tomcat03: Name or service not known

## 直接ping不通，如何解决？

## 通过--link可以解决网络联通问题，

[root@iz2ze0yjvopoflqge64bg7z docker]# docker run -P -d --name tomcat04 --link tomcat03 tomcat
df31dbf33063c3286e2d0b3c1591e835a82212914d29067be8ce0107207f7a9d
[root@iz2ze0yjvopoflqge64bg7z docker]# docker exec tomcat04 ping tomcat03
PING tomcat03 (172.18.0.3) 56(84) bytes of data.
64 bytes from tomcat03 (172.18.0.3): icmp_seq=1 ttl=64 time=0.132 ms
64 bytes from tomcat03 (172.18.0.3): icmp_seq=2 ttl=64 time=0.097 ms
64 bytes from tomcat03 (172.18.0.3): icmp_seq=3 ttl=64 time=0.106 ms

# 测试反向能否ping通
[root@iz2ze0yjvopoflqge64bg7z docker]# docker exec tomcat03 ping tomcat04
ping: tomcat04: Name or service not known
# 反向无法ping通
```

> 原理：tomcat04在本地配置了host映射

```shell
## 查看hosts配置

[root@iz2ze0yjvopoflqge64bg7z docker]# docker exec tomcat04 cat /etc/hosts
127.0.0.1	localhost
::1	localhost ip6-localhost ip6-loopback
fe00::0	ip6-localnet
ff00::0	ip6-mcastprefix
ff02::1	ip6-allnodes
ff02::2	ip6-allrouters
172.18.0.3	tomcat03 52458bf168ac
172.18.0.4	df31dbf33063
```

我们现在玩docker不推荐使用--link，docker0不支持容器名访问

## 自定义网络

容器互联

查看所有的docker网络

![image-20200520182256989](http://img.zhaojishun.cn/img/image-20200520182256989.png)

**网络模式**

- bridge 桥接
- none 不配置网络
- host 和宿主机共享网络
- container 网络联通(用的少)

**测试**

```shell
# 直接启动的命令 --net bridge是默认的，就是docker0
docker run -d -P tomcat01 --net bridge tomcat

# docker0 特点，默认域名不能访问，--link可以打通链接

# 我们可以自定义网络
# --driver bridge 网络模式
# --subnet 子网
# --gateway 网关
[root@iz2ze0yjvopoflqge64bg7z docker]# docker network create --driver bridge --subnet 192.168.0.0/16 --gateway 192.168.0.1 mynet
1f0528ef0fea92481064215f9c84dc21ce2151e78cea31a640733831ab0ff719
[root@iz2ze0yjvopoflqge64bg7z docker]# docker network ls
NETWORK ID          NAME                DRIVER              SCOPE
0dccb24aff8d        bridge              bridge              local
950d9ad8d7e6        host                host                local
1f0528ef0fea        mynet               bridge              local
5d1b9202781c        none                null                local
```

**查看自己创建的网络**

![image-20200520183456635](http://img.zhaojishun.cn/img/image-20200520183456635.png)

```shell
## 创建两个tomcat容器，使用自己创建的网络
[root@iz2ze0yjvopoflqge64bg7z docker]# docker run -d -P --name tomcat-net-01 --net mynet tomcat
ecdf2a69cc065bdee2d933c935acbd3863ef277eff3f70a1fb1ee3a168ebcd3c
[root@iz2ze0yjvopoflqge64bg7z docker]# docker run -d -P --name tomcat-net-02 --net mynet tomcat
207d8f8341adc2f967178a39c4c6837d1d76633964251863532c6887e3a37803

## 查看网络配置
[root@iz2ze0yjvopoflqge64bg7z docker]# docker network inspect mynet
[
    {
        "Name": "mynet",
        "Id": "1f0528ef0fea92481064215f9c84dc21ce2151e78cea31a640733831ab0ff719",
        "Created": "2020-05-20T18:31:13.262338476+08:00",
        "Scope": "local",
        "Driver": "bridge",
        "EnableIPv6": false,
        "IPAM": {
            "Driver": "default",
            "Options": {},
            "Config": [
                {
                    "Subnet": "192.168.0.0/16",
                    "Gateway": "192.168.0.1"
                }
            ]
        },
        "Internal": false,
        "Attachable": false,
        "Ingress": false,
        "ConfigFrom": {
            "Network": ""
        },
        "ConfigOnly": false,
        "Containers": {
            "207d8f8341adc2f967178a39c4c6837d1d76633964251863532c6887e3a37803": {
                "Name": "tomcat-net-02",
                "EndpointID": "b91c1d182bb820545b52c89e1a34ef27e80ed316cd03cded67641ddbc4c15319",
                "MacAddress": "02:42:c0:a8:00:03",
                "IPv4Address": "192.168.0.3/16",
                "IPv6Address": ""
            },
            "ecdf2a69cc065bdee2d933c935acbd3863ef277eff3f70a1fb1ee3a168ebcd3c": {
                "Name": "tomcat-net-01",
                "EndpointID": "ac55b1a94e31cca752d9e786b1b9599bc015771385a3dda37e5fb03451a9d094",
                "MacAddress": "02:42:c0:a8:00:02",
                "IPv4Address": "192.168.0.2/16",
                "IPv6Address": ""
            }
        },
        "Options": {},
        "Labels": {}
    }
]

## ip地址能够直接ping通
[root@iz2ze0yjvopoflqge64bg7z docker]# docker exec tomcat-net-01 ping 192.168.0.3
PING 192.168.0.3 (192.168.0.3) 56(84) bytes of data.
64 bytes from 192.168.0.3: icmp_seq=1 ttl=64 time=0.138 ms
64 bytes from 192.168.0.3: icmp_seq=2 ttl=64 time=0.112 ms
64 bytes from 192.168.0.3: icmp_seq=3 ttl=64 time=0.092 ms
^C

## 不使用--link 使用容器名也能ping通
[root@iz2ze0yjvopoflqge64bg7z docker]# docker exec tomcat-net-01 ping tomcat-net-02
PING tomcat-net-02 (192.168.0.3) 56(84) bytes of data.
64 bytes from tomcat-net-02.mynet (192.168.0.3): icmp_seq=1 ttl=64 time=0.065 ms
64 bytes from tomcat-net-02.mynet (192.168.0.3): icmp_seq=2 ttl=64 time=0.108 ms
64 bytes from tomcat-net-02.mynet (192.168.0.3): icmp_seq=3 ttl=64 time=0.089 ms
```

我们自定义的网络，docker都帮我们维护好了关系，推荐自定义使用网络

好处：redis集群，mysql集群，不同的集群使用不同的网络，保证集群安全和健康

## 虚拟网卡网络互通

> 链接一个容器到一个网络
>
> 本章测试前提是创建了mynet自定义网络，运行了使用自定义网络的tomcat-net-01、tomcat-net-02 容器。具体见自定义网络章节。

![image-20200520184516431](http://img.zhaojishun.cn/img/image-20200520184516431.png)

```shell
# 在docker0上创建两个tomcat
[root@iz2ze0yjvopoflqge64bg7z docker]# docker run -d -P --name tomcat01  tomcat
a5d9e17d19fb797be0275240e4b6942713cd4c3c8e9ec11a7503f3e74621250d
[root@iz2ze0yjvopoflqge64bg7z docker]# docker run -d -P --name tomcat02  tomcat
4bd49a80981e0ca3837e5a69ffba1f48381ea1a7c535826571d249f706c2d631

# 直接ping无法ping 通
[root@iz2ze0yjvopoflqge64bg7z docker]# docker exec tomcat01 ping tomcat-net-01
ping: tomcat-net-01: Name or service not known

## 测试打通
docker network connect mynet tomcat01
## 
[root@iz2ze0yjvopoflqge64bg7z docker]# docker network connect mynet tomcat01
[root@iz2ze0yjvopoflqge64bg7z docker]# docker network inspect mynet

## 打通后将tomcat01放到了mynet网络下

## 一个容器两个Ip
```

![image-20200520185054371](http://img.zhaojishun.cn/img/image-20200520185054371.png)

网络结构图

![image-20200520185154419](http://img.zhaojishun.cn/img/image-20200520185154419.png)

```shell
## 测试可以ping通
[root@iz2ze0yjvopoflqge64bg7z docker]# docker exec tomcat01 ping tomcat-net-01
PING tomcat-net-01 (192.168.0.2) 56(84) bytes of data.
64 bytes from tomcat-net-01.mynet (192.168.0.2): icmp_seq=1 ttl=64 time=0.097 ms
64 bytes from tomcat-net-01.mynet (192.168.0.2): icmp_seq=2 ttl=64 time=0.094 ms
64 bytes from tomcat-net-01.mynet (192.168.0.2): icmp_seq=3 ttl=64 time=0.087 ms
```

**结论：假设要跨虚拟网络操作别人，就需要使用docker network connect 联通！**

# Docker Compose

> TODO

# 阿里云镜像服务

阿里云为开发者提供了容器镜像服务，相当于中国的dockerhub

- 阿里云镜像加速
  https://cr.console.aliyun.com/
  ![image.png](https://img.hacpai.com/file/2019/10/image-7c54b391.png?imageView2/2/w/1280/format/jpg/interlace/1/q/100)
  复制命令执行

```
sudo mkdir -p /etc/docker
sudo tee /etc/docker/daemon.json <<-'EOF'
{
  "registry-mirrors": ["https://b32o6mfv.mirror.aliyuncs.com"]
}
EOF
sudo systemctl daemon-reload
sudo systemctl restart docker
```

- 阿里云容器镜像操作指南

1. 登录阿里云Docker Registry

```
$ sudo docker login --username=15********* registry.cn-hangzhou.aliyuncs.com
```

用于登录的用户名为阿里云账号全名，密码为开通服务时设置的密码。

您可以在访问凭证页面修改凭证密码。

1. 从Registry中拉取镜像

```
$ sudo docker pull registry.cn-hangzhou.aliyuncs.com/zhaojishun/test_web:[镜像版本号]
```

1. 将镜像推送到Registry

```
$ sudo docker login --username=15********* registry.cn-hangzhou.aliyuncs.com
$ sudo docker tag [ImageId] registry.cn-hangzhou.aliyuncs.com/zhaojishun/test_web:[镜像版本号]
$ sudo docker push registry.cn-hangzhou.aliyuncs.com/zhaojishun/test_web:[镜像版本号]
```

请根据实际镜像信息替换示例中的[ImageId]和[镜像版本号]参数。

1. 选择合适的镜像仓库地址

从ECS推送镜像时，可以选择使用镜像仓库内网地址。推送速度将得到提升并且将不会损耗您的公网流量。

如果您使用的机器位于VPC网络，请使用 registry-vpc.cn-hangzhou.aliyuncs.com 作为Registry的域名登录，并作为镜像命名空间前缀。

1. 示例

使用"docker tag"命令重命名镜像，并将它通过专有网络地址推送至Registry。

```
$ sudo docker images
REPOSITORY                                                         TAG                 IMAGE ID            CREATED             VIRTUAL SIZE
registry.aliyuncs.com/acs/agent                                    0.7-dfb6816         37bb9c63c8b2        7 days ago          37.89 MB
$ sudo docker tag 37bb9c63c8b2 registry-vpc.cn-hangzhou.aliyuncs.com/acs/agent:0.7-dfb6816
```

使用"docker images"命令找到镜像，将该镜像名称中的域名部分变更为Registry专有网络地址。

```
$ sudo docker push registry-vpc.cn-hangzhou.aliyuncs.com/acs/agent:0.7-dfb6816
```